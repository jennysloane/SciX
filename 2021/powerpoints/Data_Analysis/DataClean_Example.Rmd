---
title: "DataClean_Example"
output: html_document
---
This script is written for you to learn how to (later in the course) clean your own data and to test your hypotheses.   

### load libraries
We start with loading the needed libraries. Remember, if you are using a package for the first time, you'll need to install it first: install.packages("your_package")
```{r}
library(here)
library(dplyr)
library(tidyverse)
library(ggplot2)
library(ggeasy)
```

We will start by calling in our fake data. We will proceed to manipulating the data, then plot the data, and finally go through some statistical tests to examine our hypothesis.

### 1. here 
First, we want to ensure that we are in our Rproject, where all the rest of the files are stored. We will do so by using the 'here' function
```{r}
here()
```


### 2. read in data 
We will call in the data (file: 'Example_SciX.csv') and will assign it into an object name: 'My_Data'
```{r}
My_Data = read.csv(file = "Example_SciX.csv")
```


### 3. head
Now, lets take a brief look into our data. As the R console is too small to display the full table, we will look only at the top part of the table. To do so we will use the 'head' function. 
```{r}
head(My_Data)
```


### 4. data structure 
Its important to look at structure of your data (i.e. number of columns, their type and the number of rows/observations). For that, we will use the function 'str'. 
```{r}
str(My_Data)
```

### 4.1. tidy data 
Another way to view your data is a "tidy" way is to convert it to a tibble (which is a simple dataframe). 
```{r}
My_Data <- My_Data %>%
  as_tibble(My_Data)
```


### 5. change variable type 
Hmmmmm..... something is weird... the variable Gender is a type 'int' (int = integer). This means that R considers females as equal to 0 and male to 1. However, I wanted Gender values (i.e. 0 and 1) to represent categories and not mathematical values (females' value is not 0, right? ;)). We have to tell R to treat those values as categories. The correct type for categorizing a variable in R is a factor/character. We use the function 'as.factor' to change the type of Gender to categories. 
```{r}
My_Data$Gender = as.factor(My_Data$Gender)
My_Data # Lets look at the columns once again to ensure that our variable's type changed. 
```


### 6. select rows 
Great... but there are still some super silly columns that we can get rid of (unless you are really interested in the link between the number of cats and shoes size). This will make our life easier and we will be able to look only at the columns we are interested in. Remember, our hypothesis is: There is a link between Gender and IQ scores. Here, we will ask R to give us only the columns of interest: 'ID', 'Gender' and 'IQ_Score'. We will assign this new subset-data into a new variable called My_SubData. 
```{r}
My_SubData = My_Data %>%
  select(ID, Gender, IQ_Score)

```

### 7. rename
Lets say that now I want to change the name of the IQ_Score column to IQ_TestResults. We can do so by using the 'rename' function within 'dplyr' package (that you should know a bit by now). Super easy.. 
```{r}
My_SubData = My_SubData %>% rename(IQ_TestResults = IQ_Score) # Voila!  
```


### 8. recode 
Now, Gender = 0/1 is not clear enough and that we can later on forget what the categories/coding mean. We can solve this by creating a new column (in dplyr it is called 'mutate') that will contain the letter F if Gender = 0 and the letter M if Gender = 1. We will use the 'recode' function within 'dplyr' package to assign the right letters to the right categories. 
```{r}
My_SubData = My_SubData %>% 
              mutate(Gender_Name = recode(My_SubData$Gender, "0" = "F", "1" = "M"))
```

### 9. summary stats 
Looking good! Now lets look at some summary statistics. We will use the 'summary' function to investigate the IQ scores of our participants. Also, we will use the function 'table' to know how many men and women we have in our data-set. 
```{r}
summary(My_SubData$IQ_TestResults)
table(My_SubData$Gender_Name)
```


### 10. filter 
Another useful tool in R is the ability to easily filter our data. For instance, we can look at the data of the fifth participant (i.e. ID = 5) only. There are many eays to do so. Here we will use the 'filter' function. This function takes the data you wish to filter and 'cuts out' the part of the data-set you wish to obtain. We will assign the fifth participant's data into a new object that is called 'Data_ID5'
```{r}
Data_ID5 <- My_SubData %>%
  filter(ID == 5) # you should obtain a 1-row data-set that has the details of ID = 5 only. Quiz: what is the IQ score of this participant?
```

Here is another example of the 'filter' function: Lets say we want to look at the data of those participants with IQ_Score greater than 120.
```{r}
Data_Partial_IQ <- My_SubData %>%
  filter(IQ_TestResults > 120) # this data-set will have 23 rows in it
```


### 11. reverse coding 
Sometimes surveys have items that need to be "reverse coded", which means that some items are scored in the opposite direction. For example, the impulsivity survey has a scale from 1 (rarely/never) to 4 (almost always/always). Let's look at two items as an example. Item #2 is: "I do things without thinking", so 4 on the scale represents someone who is impulsive. On the other hand, item #1 is: "I plan tasks carefully", so here 4 on the scale represents someone who is NOT impulsive. Therefore, this item must be reverse coded, so we must make 0=4, 1=3, 2=2, 3=1, and 4=0. Here's some code to show you how we can do this easily with R.

First, let's add fake survey items to the data, so we can practice reverse coding
```{r}
My_Data_R <- My_SubData %>%
  mutate(item1 = sample(c(1,2,3,4), 300, replace=TRUE), 
         item2 = sample(c(0,1,2,3,4), 300, replace=TRUE),
         item3 = sample(c(0,1,2,3,4), 300, replace=TRUE))

```

To reverse code item1, we need to make: 1=4, 2=3, 3=2, 4=1
Double check to make sure item1 is the reverse of item1_reverse!
```{r}
My_Data_R %>%
  select(ID, item1) %>%
  mutate(item1_R = dplyr::recode(My_Data_R$item1, "1" = "4", # R for reverse
                                               "2" = "3",
                                               "3" = "2",
                                               "4" = "1"))
```

To reverse code item2, we need to make: 0=4, 1=3, 2=2, 3=1, 4=0
```{r}
My_Data_R %>%
  select(ID, item2) %>%
  mutate(item2_R = dplyr::recode(My_Data_R$item1, "0" = "4",
                                               "1" = "3",
                                               "2" = "2",
                                               "3" = "1",
                                               "4" = "0"))
```

We can do it all together like this
```{r}
My_Data_reverse <- My_Data_R %>%
  mutate(item1_R = dplyr::recode(My_Data_R$item1, "1" = "4", "2" = "3", "3" = "2", "4" = "1"), 
         item2_R = dplyr::recode(My_Data_R$item1, "0" = "4", "1" = "3", "2" = "2", "3" = "1", "4" = "0")) %>%
  select(-c(item1,item2)) # we no longer need item1 and item2 because we have item1_R and item2_R
```


### 12. plot 
We can now start to plot the data we have.

Remember, our sample research question is to see if gender is related to IQ? We'll use the My_SubData here
```{r}
My_SubData
```


geom_point() plots a point for every data point. 
aes() is to specify the aesthetics.
This isn't so informative though, just a lot of dots on top of each other. 
```{r}
ggplot(My_SubData, aes(x = Gender_Name, y = IQ_TestResults)) + 
  geom_point() 
```


geom_jitter() plots the same as geom_point, but "jitters" the points so not on top of each other (I've also added color in)
```{r}
ggplot(My_SubData, aes(x = Gender_Name, y = IQ_TestResults, color=Gender_Name)) + 
  geom_jitter() 
```

geom_histogram() plots a histogram
```{r}
ggplot(My_SubData, aes(IQ_TestResults, fill=Gender_Name)) + # note fill here instead of color because you fill in bars, but color in points
  geom_histogram(bins = 20) 
```

facet_wrap() divides the plot by a selected variable
```{r}
ggplot(My_SubData, aes(IQ_TestResults, fill=Gender_Name)) + 
  geom_histogram(bins = 20) +
  facet_wrap(~Gender_Name) 
```

geom_density() a smoothed version of the histogram
```{r}
ggplot(My_SubData, aes(IQ_TestResults, fill=Gender_Name)) +  
  geom_histogram(aes(y = ..density..), bins = 20, color="black") + # density rather than count, same as count just a different scale. area beneath density curve = 1
  geom_density(bins = 20, alpha=.4) +
  facet_wrap(~Gender_Name) 
```

boxplot() plots a boxplot. This one is especially useful to compare IQ by gender. 
We can see the red and blue lines are at about the same IQ level, which gives us reason to believe there may not be a difference between male and female IQ (but we'll have to do a statistical test to be confident)
```{r}
ggplot(My_SubData, aes(x = Gender_Name, y = IQ_TestResults, color=Gender_Name)) + 
  geom_boxplot()
```

Let's make this boxplot prettier!
```{r}
ggplot(My_SubData, aes(x = Gender_Name, y = IQ_TestResults, color=Gender_Name)) + 
  geom_boxplot() +
  theme_bw() + # changes the theme (I like the black/white theme)
  labs(x = "Gender", y = "IQ Score", title = "") + 
  easy_all_text_size(size=20) +
  easy_remove_legend() 

```

### 13. statistical analyses 
descriptive statistics (e.g mean, median, etc)
```{r}
mean(My_Data_R$IQ_TestResults)
median(My_Data_R$IQ_TestResults)
min(My_Data_R$IQ_TestResults)
max(My_Data_R$IQ_TestResults)
```

t test = compares means of 2 groups 
remember, if p < 0.05 there is a significant difference between the two groups
```{r}
female_scores <- My_Data_R %>%
  filter(Gender_Name == "F")
female_scores$IQ_TestResults
mean(female_scores$IQ_TestResults)

male_scores <- My_Data_R %>%
  filter(Gender_Name == "M")
male_scores$IQ_TestResults
mean(male_scores$IQ_TestResults)

t.test(female_scores$IQ_TestResults, male_scores$IQ_TestResults) # Because here p > 0.05, we can say our results provide evidence that there is NO difference between male and female IQ scores
```

cor.test = correlation between 2 continuous variables
```{r}
cor.test(My_Data_R$IQ_TestResults, My_Data_R$Gender_Name) # this won't work
cor.test(My_Data_R$item1, My_Data_R$IQ_TestResults) # this will work
```

chisq.test = test between 2 categorical variables
```{r}
# data to look at chisquared test 
iris_dat <- iris %>%
  as_tibble()
str(iris_dat)

iris_dat$size <- ifelse(iris_dat$Sepal.Length < median(iris_dat$Sepal.Length),
  "small", "big"
)
iris_dat$size <- as.factor(iris_dat$size)
str(iris_dat)

# chisquared test has to be in the form of a contingency table, like below (simply use the table function)
chi_table <- table(iris_dat$Species, iris_dat$size)
chi_table
chisq.test(chi_table)
```


ANOVA - analysis of variance, analyze the differences among group means in a sample (especially useful if you are comparing more than 2 groups)
```{r}
anova1 <- aov(IQ_TestResults ~ Gender_Name, data = My_Data_R)
summary(anova1) # does this p value look familiar? yes, this is the same as the t test we completed above! 

# are the sepal widths different between the different species? species has 3 groups, so an ANOVA here is better than multiple t tests
iris_dat
levels(iris_dat$Species)
anova2 <- aov(Sepal.Width ~ Species, data = iris_dat)
summary(anova2)

```
